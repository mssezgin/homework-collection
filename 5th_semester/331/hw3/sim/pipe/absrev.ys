#/* $begin absrev-ys */
##################################################################
# absrev.ys - Reverse a src block of len words to dst.
# Return the sum of absolute values of words contained in src.
#
# Include your name and ID here.
# Describe how and why you modified the baseline code.
##################################################################
#
#    mustafa sezgin
#    2380863
#
# 1. reduction in strength: instead of setting rcx to 0 and
#    using eight additions, i set rcx to len (rdx) and add rcx
#    to itself three times.
#    (-5 instruction per program)
#    avg: 17.83 -> 17.46
#
# 2. instead of using another register (rcx) to hold dst_rev,
#    i convert dst (rsi) to dst_rev.
#    (-1 instruction per program)
#    also, rdx now holds eight times length and is decremented
#    by eight at each iteration as if it were a pointer, which
#    eliminates setting r10 to 1.
#    (-1 instruction per iteration)
#    avg: 17.46 -> 16.38
#
# 3. code motion: i used r8 (instead of r10) as a constant global
#    variable to hold 8 for addq and subq.
#    (-1 instruction per iteration)
#    avg: 16.38 -> 15.38
#
# 4. i deleted the first condition check and keep the one
#    (labeled as Condition) that is at the end of the loop body.
#    this condition check is prone to continuing the iteration
#    and misprediction happens only once (before returning).
#    (-1 instruction per program)
#    avg: 15.38 -> 15.31
##################################################################
# Do not modify this portion
# Function prologue.
# %rdi = src, %rsi = dst, %rdx = len
absrev:
##################################################################
# You can modify this portion
	# Loop header
	xorq	%rax,%rax	# sum = 0;
    
	# all this for dst_rev = dst + len - 1
	irmovq	$8,%r8		# const for addq and subq
	addq	%rdx,%rdx	# rdx = len * 2
	addq	%rdx,%rdx	# rdx = len * 4
	addq	%rdx,%rdx	# rdx = len * 8
	addq	%rdx,%rsi	# rsi = dst + len * 8
	subq	%r8,%rsi	# rsi = dst + len * 8 - 8
	jmp	Condition	# first, check condition
Loop:    
	mrmovq	(%rdi),%r10	# read val from src...
	rmmovq	%r10,(%rsi)	# ...and store it to dst
	andq	%r10,%r10	# val >= 0?
	jge	Positive	# if so, skip negating
	rrmovq	%r10,%r9	# temporary move
	xorq	%r10,%r10	# zero r10
	subq	%r9,%r10	# negation achieved!
Positive:
	addq	%r10,%rax	# sum += absval
	subq	%r8,%rdx	# len--
	addq	%r8,%rdi	# src++
	subq	%r8,%rsi	# dst_rev--
Condition:
	andq	%rdx,%rdx	# check if len > 0
	jg	Loop		# if so, goto Loop:
##################################################################
# Do not modify the following section of code
# Function epilogue.
Done:
	ret
##################################################################
# Keep the following label at the end of your function
End:
#/* $end absrev-ys */
