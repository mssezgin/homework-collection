#/* $begin absrev-ys */
##################################################################
# absrev.ys - Reverse a src block of len words to dst.
# Return the sum of absolute values of words contained in src.
#
# Include your name and ID here.
# Describe how and why you modified the baseline code.
##################################################################
# mustafa sezgin
# 2380863
#
# 1. instead of setting rcx to 0 and using eight additions,
#    i set rcx to rdx and used seven additions
#    (-1 instruction per program)
#    avg: 17.83 -> 17.76
#
# 2. instead of adding length to rcx seven times, i add rcx
#    to itself three times
#    (-4 instructions per program)
#    avg: 17.76 -> 17.46
#
# 3. instead of using another register (rcx) to hold dst_rev,
#    i convert dst (rsi) to dst_rev,
#    also length is now eight times its value and is decremented
#    by eight at each iteration as if it were a pointer, which
#    which elminates keeping 1 and 8 in seperate registers
#    for addq and subq
#    (-1 instruction per program)
#    (-1 instruction per iteration)
#    avg: 17.46 -> 16.38
#
# 4. i used r8 as a constant global variable for addq and subq
#    (-1 instruction per iteration)
#    avg: 16.38 -> 15.38
#
# 5. i eliminated the first condition check, created Condition
#    label
#    (-1 instruction per program)
#    avg: 15.38 -> 15.31
##################################################################
# Do not modify this portion
# Function prologue.
# %rdi = src, %rsi = dst, %rdx = len
absrev:
##################################################################
# You can modify this portion
	# Loop header
	xorq	%rax,%rax	# sum = 0;
    
	# all this for dst_rev = dst + len - 1
	irmovq	$8,%r8		# const for addq and subq
	addq	%rdx,%rdx	# rdx = len * 2
	addq	%rdx,%rdx	# rdx = len * 4
	addq	%rdx,%rdx	# rdx = len * 8
	addq	%rdx,%rsi	# rsi = dst + len * 8
	subq	%r8,%rsi	# rsi = dst + len * 8 - 8
	jmp	Condition	# first, check condition
Loop:    
	mrmovq	(%rdi),%r10	# read val from src...
	rmmovq	%r10,(%rsi)	# ...and store it to dst
	andq	%r10,%r10	# val >= 0?
	jge	Positive	# if so, skip negating
	rrmovq	%r10,%r9	# temporary move
	xorq	%r10,%r10	# zero r10
	subq	%r9,%r10	# negation achieved!
Positive:
	addq	%r10,%rax	# sum += absval
	subq	%r8,%rdx	# len--
	addq	%r8,%rdi	# src++
	subq	%r8,%rsi	# dst_rev--
Condition:
	andq	%rdx,%rdx	# check if len > 0
	jg	Loop		# if so, goto Loop:
##################################################################
# Do not modify the following section of code
# Function epilogue.
Done:
	ret
##################################################################
# Keep the following label at the end of your function
End:
#/* $end absrev-ys */
